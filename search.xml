<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式-工厂模式]]></title>
    <url>%2F2020%2F03%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(2) 工厂模式工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。属于创建型设计模式，提供了一种最佳的创建对象的最佳方式。 含义定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建的过程延迟到子类进行。 实现首先创建一个Shape接口和创建实现Shape的实体类，下一步是定义一个工厂类ShapeFactory，和测试工厂类FactoryTest来演示获取对象的过程，它将向ShapeFactory传递消息，获取它所需要的对象类型。 源码Shape接口12345678910111213package top.zwhzzz.Design.Factory;/** * @ClassName Shape * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:13 * @Version 1.0 *///定义一个接口类public interface Shape &#123; void draw();&#125; Circle类1234567891011121314151617package top.zwhzzz.Design.Factory;/** * @ClassName Circle * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:15 * @Version 1.0 *///实体类Circlepublic class Circle implements Shape&#123; @Override public void draw() &#123; System.out.println("调用方法：=&gt; Circle"); &#125;&#125; Rectangle实体类12345678910111213141516package top.zwhzzz.Design.Factory;/** * @ClassName Rectangle * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:18 * @Version 1.0 *///实体类Rectanglepublic class Rectangle implements Shape&#123; @Override public void draw() &#123; System.out.println("调用方法：=&gt; Rectangle"); &#125;&#125; Square实体类12345678910111213141516package top.zwhzzz.Design.Factory;/** * @ClassName Square * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:18 * @Version 1.0 *///实体类Squarepublic class Square implements Shape&#123; @Override public void draw() &#123; System.out.println("调用方法：=&gt; Square"); &#125;&#125; ShapeFactory工厂类1234567891011121314151617181920212223242526272829303132package top.zwhzzz.Design.Factory;/** * @ClassName ShapeFactory * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:31 * @Version 1.0 *///形状工厂，生成基于给定信息的实体类的对象名称public class ShapeFactory &#123; //获取形状的类型的对象 public Shape getShape(String shapeType) &#123; if(shapeType == null) &#123; return null; &#125; //Circle if(shapeType.equalsIgnoreCase("Circle")) &#123; return new Circle(); &#125; //Rectangle if(shapeType.equalsIgnoreCase("Rectangle")) &#123; return new Rectangle(); &#125; //Square if(shapeType.equalsIgnoreCase("Square")) &#123; return new Square(); &#125; return null; &#125;&#125; FactoryTest测试类12345678910111213141516171819202122232425262728package top.zwhzzz.Design.Factory;/** * @ClassName FactoryTest * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:46 * @Version 1.0 *///测试工厂类public class FactoryTest &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //Circle ==&gt;利用工厂对Circle进行实例化，获取对象，调用方法。 Shape circle = shapeFactory.getShape("Circle"); circle.draw(); //Rectangle ==&gt;获取Rectangle对象，利用接口调用实现的方法 Shape rectangle = shapeFactory.getShape("Rectangle"); rectangle.draw(); //square ==&gt;获取square对象，利用接口调用实现的方法 Shape square = shapeFactory.getShape("Square"); square.draw(); &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例模式]]></title>
    <url>%2F2020%2F03%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(1) 单例模式单例模式的概念单例模式是比较常见的一种设计模式，设计的目的是保证一个类有一个实例，而且自行实例化并向整个系统提供这个实例，避免频繁创建对象，可以提高对象的复用性，节约内存。 类加载(classLoader)的顺序类加载(classLoader)机制一本遵循以下几种顺序。 先执行父类的静态代码块和静态变量初始化 执行子类的静态代码块和静态变量初始化 执行父类的实例变量初始化 执行父类的构造函数 执行子类的实例变量初始化 执行子类的构造函数 特别注意，加载类的过程是线程私有的，别的线程无法进入。 两种实现方式–懒汉和饿汉在单例模式的实现过程中，一般分为懒汉式和饿汉式。懒汉式：在类加载时不完成初始化，等到第一次使用时才实例化，实现的是懒加载模式。饿汉式：在类加载时就完成了初始化，所以类加载比较慢，获取对象的速度却比较快。 源码饿汉式12345678910111213141516171819202122232425package top.zwhzzz.Design.Singletone;/** * @ClassName SingletonErHan 单例模式==&gt;恶汉模式 * @Description TODO * @Author TomAlen * @Date 2020/3/9 15:14 * @Version 1.0 *///恶汉式的设计模式：在类加载的过程中进行了实例化， 避免了多线程的的同步问题。public class SingletonErHan &#123; private static final SingletonErHan singletonErHan = new SingletonErHan(); //无参构造器 public SingletonErHan() &#123; &#125; //getter方法，获取实例化的singletonErHan public static SingletonErHan getSingletonErHan() &#123; return singletonErHan; &#125;&#125; 懒汉式12345678910111213141516171819202122232425262728package top.zwhzzz.Design.Singletone;/** * @ClassName SingletonLanHan 单例模式==&gt;懒汉模式 * @Description TODO * @Author TomAlen * @Date 2020/3/9 15:15 * @Version 1.0 *///懒汉式单例模式，在类实例化的时候进行懒加载，添加了synchronized关键字，解决了线程不安全的问题。public class SingletonLanHan &#123; private static SingletonLanHan singletonLanHan = null; public SingletonLanHan() &#123; &#125; //加锁机制，如果有两个线程同时访问，一个进入线程中，另一个则在等待，解决了线程不安全的问题。但是缺点也很明显，因为synchronized是修饰整个方法，每个线程访问都要进行同步，会造成资源的浪费。 public static synchronized SingletonLanHan getSingletonLanHan() &#123; if(singletonLanHan == null) &#123; singletonLanHan = new SingletonLanHan(); &#125; return singletonLanHan; &#125;&#125; 双层检查懒汉式123456789101112131415161718192021222324252627282930package top.zwhzzz.Design.Singletone;/** * @ClassName SingletonLanHanDouble * @Description TODO * @Author TomAlen * @Date 2020/3/9 17:09 * @Version 1.0 *///双重检查懒汉式public class SingletonLanHanDouble &#123; private static volatile SingletonLanHanDouble instance= null; public SingletonLanHanDouble() &#123; &#125; //synchronized关键字加在代码块上了，而不是在方法上，可以提高效率。 public static SingletonLanHanDouble getInstance() &#123; if(instance == null) &#123; synchronized (SingletonLanHanDouble.class) &#123; if(instance == null) &#123; instance = new SingletonLanHanDouble(); &#125; &#125; &#125; return instance; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法--数组中重复的数]]></title>
    <url>%2F2020%2F03%2F09%2F%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[算法–数组中重复的数算法描述在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 12 &lt;= n &lt;= 100000 来源：力扣（LeetCode） 个人思路因为是要在数组中找出重复的数,所以第一思路就是用Set集合进行存储，而要找出任意一个数即可，所以只要出现了这个数，就可以跳出循环了。 1 初始化一个Set集合，存储不重复的元素 2 初始化一个重复的数字repeat = 0 3 遍历数组 如果set存储了重复的元素，就添加不成功，跳出循环，将重复的数字赋值给repeat 具体代码123456789101112131415class Solution &#123; public int findRepeatNumber(int[] nums) &#123; //思路：初始化一个Set集合，存储不重复的数字 Set&lt;Integer&gt; sets = new HashSet&lt;&gt;(); int repates = 0; //遍历数组 for (int num : nums) &#123; if(!sets.add(num)) &#123; repates = num; break; &#125; &#125; return repates; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN、APN]]></title>
    <url>%2F2020%2F03%2F06%2FVPN%E3%80%81APN%2F</url>
    <content type="text"><![CDATA[VPN和APN的概念最近项目经理给了我一个任务，就是去了解下VPN、APN技术，作为计算机网络的菜鸡，感觉这是一个艰巨的任务，但是作为项目中的一员，还得去干~ VPNVPN全名为虚拟专用网络，属于远程访问技术，简单的说就是利用公用网络架设私有网络。可以这样理解，利用公共的网通过VPN这个桥梁搭建自己的私有网络，其中也有这样一层说法，就是翻墙。具体在win10的操作流程为： 打开“网络和Intenet设置”，选择VPN 添加VPN连接 填写相关的参数 服务器或地址填写要访问的内网数据的ip地址 用户名和密码则是要访问的公司给的VPN账号 APNAPN是一种网络接入技术，通过手机上网设置的一个参数，决定了手机通过哪种接入方式来访问网络。具体的做法如下： 1：打开手机设置 2：点击”双卡和移动网络” 3：点击”中国移动/联通/电信” 4：点击”接入点名称(APN)” 5：点击新建APN，输入相应的设置后保存即可访问你自己设置的接入点来访问网络。]]></content>
      <tags>
        <tag>VPN</tag>
        <tag>APN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的常用操作]]></title>
    <url>%2F2020%2F03%2F05%2FGit%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Git的常用操作什么是GitGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。在很多的公司里都在使用这种版本控制工具，可以有效的对代码进行管理，能有效的开展协同办公，使公司员工能各司其职，便于公司的开发和项目管理。 Git的常规操作这里简单介绍一下本人常用的Git操作。 1、查看本次操作属于哪个分支上 1git branch 2、新建一个新的分支xxx 1git checkout -b xxx 3、查看本地库的状态 1git status 4、将代码添加到暂存区 1git add . 5、将代码提交到本地库，将本次提交备注为xxxxx 1git commit -m "xxxxx" 6、将代码提交到远程仓库 12345&lt;!-- 第一次提交 --&gt;git push -u origin xxx &lt;!-- 第一次提交后 --&gt;git push 7、更新本地代码 1git pull 8、将分支xxx的代码合并到master分支上,首先得切换到主分支master上，将分支xxx的代码合并，最后提交到远程仓库。 123git checkout mastergit merge xxxgit push 今天是3月5日，是2020年的第一篇博客，我承认自己最近有点懒，所以要走出舒适圈，对自己进行充电学习，特别是在这个疫情大环境下，如果不想被社会淘汰，那就好好努力吧！]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2019%2F09%2F02%2F%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[联系方式 手机：15279615192 Email：zwhzzz1127@gmail.com 微信号：zwh15279615192 QQ： 1127568664 个人信息 姓名：钟炜宏 性别：男 年龄：23 学历：本科 工作经验：1年 毕业院校：九江学院 所学专业：信息管理与信息系统 所获证书：计算机二级Java、CET-4、软件设计师 技术博客：https://www.zwhzzz.top 期望职位：Java工程师 期望薪资：10k 期望城市：深圳 个人介绍本人毕业于九江学院，在校期间主要对Java方面的进行了学习，大四期间在广州奥格智能科技有限公司南昌分公司进行实习，在此期间学会了很多学校里学不到的东西。本人的熟悉运用SpringBoot、SSM框架，了解前端的Vue+ElementUI、JQuery以及BootStrap框架，熟悉掌握数据库基本理论，熟练MySQL的使用。本人对编程具有浓厚的兴趣！ 工作经验 项目经历毕业设计-基于SSM的酒店管理系统的设计与实现 2019年07月 这是一个基于SSM框架的酒店管理系统，前端采用easyUI框架，使用mysql数据库进行后台数据库的搭建，应用ECharts工具完成营业额的数据可视化操作。主要的功能有后台用户信息管理、后台用户角色管理、后台用户权限分配、菜单管理、楼层管理、房型管理、房间管理、客户管理、预定订单管理、入住管理、统计分析管理、日志管理等功能。具体的项目请见 https://github.com/TomAlen/tomalen1.github.io.git 基于SSM的学生管理系统的设计与实现 2019年03月 一个基于SSM框架的简单的学生管理系统，可以对管理员、学生、教师、班级以及年级的简单的增删改查操作，涉及到模糊查询、分页查询。运用了权限分配的知识对管理员、学生、教师三者进行权限分配。前端用的是easy-ui框架,后台使用mysql数据库进行后台的数据搭建。具体的项目请见 https://github.com/TomAlen/tomalen1.github.io.git 招聘信息系统的设计与实现 2018年09月 招聘信息系统是本人写的第一个基于SSM框架的系统，后端采用 spring+spring-mvc+mybatis框架进行设计和编写，数据库采用mysql数据库。前端采用的是layui框架。其主要功能有对简历的增删改查、对用户信息的增删改查、对招聘信息的维护和发布。]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>简历</tag>
        <tag>个人历程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot对Github授权登录操作]]></title>
    <url>%2F2019%2F08%2F26%2FSpringBoot%E5%AF%B9Github%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[SpringBoot对Github授权登录操作首先了解github授权的API流程，具体网址登陆github的官网https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/创建OAuth应用程序，在githubAPI上有具体的操作。具体见https://developer.github.com/apps/building-oauth-apps/creating-an-oauth-app/ 有详细的操作步骤。注册完如图所示： 具体的操作流程 社区发送authorize Github回调redirect_url给社区 社区发送access_token携带code Github返回access_token 社区发送User携带access_token Github返回user信息给社区 存取数据。更新登录状态 把从scope获取到的user信息返回给user 代码实现授权登录1、先定义一个AuthorizeController，把从后端获取的user回调信息返回到主页面 1234567891011121314151617181920212223242526@Autowiredprivate GithubProvider githubProvider;/** * 授权github返回主页面 * @param code * @param state * @return */@GetMapping("/callback")public String callback(@RequestParam(name = "code")String code, @RequestParam(name = "state")String state) &#123; //实例化AccessTokenDTO AccessTokenDTO accessTokenDTO = new AccessTokenDTO(); accessTokenDTO.setCode(code); accessTokenDTO.setRedirect_uri("http://localhost:8080/callback"); accessTokenDTO.setClient_id("自己注册的client_id"); accessTokenDTO.setState(state); accessTokenDTO.setClient_secret("自己注册的client_secret"); String accessToken = githubProvider.getAccessToken(accessTokenDTO); //得到Github User信息 GithubUser githubUser = githubProvider.githubUser(accessToken); System.out.println(githubUser.getName()); return "index";&#125; 2、定义DTO数据传输模型，对要转换的数据进行操作。 对获取的AccessToken进行定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class AccessTokenDTO &#123; //githubAPI第二步： GitHub将用户重定向回您的网站 返回的类型参数 private String client_id; private String client_secret; private String code; private String redirect_uri; private String state; public String getClient_id() &#123; return client_id; &#125; public void setClient_id(String client_id) &#123; this.client_id = client_id; &#125; public String getClient_secret() &#123; return client_secret; &#125; public void setClient_secret(String client_secret) &#123; this.client_secret = client_secret; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getRedirect_uri() &#123; return redirect_uri; &#125; public void setRedirect_uri(String redirect_uri) &#123; this.redirect_uri = redirect_uri; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125;&#125; github获取的用户模型 123456789101112131415161718192021222324252627282930313233public class GithubUser &#123; //github的姓名 private String name; //id private Long id; //描述 private String bio; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getBio() &#123; return bio; &#125; public void setBio(String bio) &#123; this.bio = bio; &#125;&#125; 3、定义一个提供者，具体作用为相当于一个中间件，对获取的数据进行操作。其中涉及了okHttp的测试工具，具体可见okHttp官网进行学习：https://square.github.io/okhttp/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Componentpublic class GithubProvider &#123; /** * 第一步、 * 得到AccessToken * @param accessTokenDTO * @return */ public String getAccessToken(AccessTokenDTO accessTokenDTO)&#123; MediaType mediaType = MediaType.get("application/json; charset=utf-8"); OkHttpClient client = new OkHttpClient(); //把MediaType对象解析成srting类型 RequestBody body = RequestBody.create(mediaType,JSON.toJSONString(accessTokenDTO)); Request request = new Request.Builder() //github重定向个人网站url，交换access_token .url("https://github.com/login/oauth/access_token") .post(body) .build(); try (Response response = client.newCall(request).execute()) &#123; //得到返回的access_token String string = response.body().string(); //拆分得到access_token //先以&amp;号拆分，后以=号拆分 String[] split = string.split("&amp;"); String tokenString = split[0]; String access_token = tokenString.split("=")[1]; System.out.println(string); return access_token; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; /** * 把得到的accessToken传入User对象，得到user对象的信息 * 得到返回的Scope的User信息 * 定义的githubUser有三个属性 * @param accessToken * @return */ public GithubUser githubUser(String accessToken) &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("https://api.github.com/user?access_token=" + accessToken) .build(); try&#123; Response response = client.newCall(request).execute(); String string = response.body().string(); //把得到的从url得到的json数据解析成GithubUser类对象 GithubUser githubUser = JSON.parseObject(string, GithubUser.class); return githubUser; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; 具体的操作就是这样。写的不怎么好，原理大致就是这样。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Github - SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合MongoDB]]></title>
    <url>%2F2019%2F08%2F20%2FSpringBoot%E6%95%B4%E5%90%88MongoDB%2F</url>
    <content type="text"><![CDATA[SpringBoot整合MongoDB那么什么是MongoDB？定义MongoDB 是一个基于分布式文件存储的数据库。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 MongoDB（来自于英文单词“Humongous”，中文含义为“庞大”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。作为一个适用于敏捷开发的数据库，MongoDB的数据模式可以随着应用程序的发展而灵活地更新。与此同时，它也为开发人员 提供了传统数据库的功能：二级索引，完整的查询系统以及严格一致性等等。 MongoDB能够使企业更加具有敏捷性和可扩展性，各种规模的企业都可以通过使用MongoDB来创建新的应用，提高与客户之间的工作效率，加快产品上市时间，以及降低企业成本。 MongoDB是专为可扩展性，高性能和高可用性而设计的数据库。 它可以从单服务器部署扩展到大型、复杂的多数据中心架构。利用内存计算的优势，MongoDB能够提供高性能的数据读写操作。 MongoDB的本地复制和自动故障转移功能使您的应用程序具有企业级的可靠性和操作灵活性。 简单来说，MongoDB是一个基于分布式文件存储的数据库，它是一个介于关系数据库和非关系数据库之间的产品，其主要目标是在键/值存储方式（提供了高性能和高度伸缩性）和传统的RDBMS系统（具有丰富的功能）之间架起一座桥梁，它集两者的优势于一身。 MongoDB支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型，也因为他的存储格式也使得它所存储的数据在Nodejs程序应用中使用非常流畅。 传统的关系数据库一般由数据库（database）、表（table）、记录（record）三个层次概念组成，MongoDB是由数据库（database）、集合（collection）、文档对象（document）三个层次组成。MongoDB对于关系型数据库里的表，但是集合中没有列、行和关系概念，这体现了模式自由的特点。 MongoDB中的一条记录就是一个文档，是一个数据结构，由字段和值对组成。MongoDB文档与JSON对象类似。字段的值有可能包括其它文档、数组以及文档数组。MongoDB支持OS X、Linux及Windows等操作系统，并提供了Python，PHP，Ruby，Java及C++语言的驱动程序，社区中也提供了对Erlang及.NET等平台的驱动程序 MongoDB使用原理是什么?所谓“面向集合”（Collection-Oriented），意思是数据被分组存储在数据集中，被称为一个集合（Collection)。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档。集合的概念类似关系型数据库（RDBMS）里的表（table），不同的是它不需要定义任何模式（schema)。Nytro MegaRAID技术中的闪存高速缓存算法，能够快速识别数据库内大数据集中的热数据，提供一致的性能改进。模式自由（schema-free)，意味着对于存储在mongodb数据库中的文件，我们不需要知道它的任何结构定义。如果需要的话，你完全可以把不同结构的文件存储在同一个数据库里。存储在集合中的文档，被存储为键-值对的形式。键用于唯一标识一个文档，为字符串类型，而值则可以是各种复杂的文件类型。我们称这种存储形式为BSON（Binary Serialized Document Format）。 核心NoSql的定义NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。适用于分布式计算场景 MongoDB的下载安装下载地址：https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2012plus-4.2.0-signed.msi 下载的网速有点慢，毕竟是国外的网站。windows下安装采用傻瓜式安装，直接下一步就行啦~ springBoot集成1、maven下加入依赖包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 2、application.yml配置连接12345spring: data: mongodb: uri: mongodb://test:123@localhost:27017/testdb 3、在项目入口启动类上面加一个注解。开启Mongodb审计功能.1@EnableMongoAuditing 4、数据库层操作Dao1234public interface ArticleDao extends MongoRepository&lt;Article,String&gt; &#123; //支持关键字查询，和JPA的用法一样 Article findByAuthor(String author);&#125; 以上就是SpringBoot整合MongoDB的做法。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis集成atomikos实现分布式事务]]></title>
    <url>%2F2019%2F08%2F19%2Fmybatis%E9%9B%86%E6%88%90atomikos%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[mybatis集成atomikos实现分布式事务什么是jta-atomikos以及分布式事务？Atomikos 是一个为Java平台提供增值服务的并且开源类事务管理器。分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简而言之，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。 整合jta-atomikos1、引入依赖包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置yml文件，配置双数据源1234567891011121314151617181920212223primarydb: uniqueResourceName: primary xaDataSourceClassName: com.mysql.jdbc.jdbc2.optional.MysqlXADataSource xaProperties: url: jdbc:mysql://localhost:3306/springboot user: root password: root exclusiveConnectionMode: true minPoolSize: 3 maxPoolSize: 10 testQuery: SELECT 1 from dual #由于采用HikiriCP，用于检测数据库连接是否存活。secondarydb: uniqueResourceName: secondary xaDataSourceClassName: com.mysql.jdbc.jdbc2.optional.MysqlXADataSource xaProperties: url: jdbc:mysql://localhost:3306/springboot1 user: root password: root exclusiveConnectionMode: true minPoolSize: 3 maxPoolSize: 10 testQuery: SELECT 1 from dual #由于采用HikiriCP，用于检测数据库连接是否存活。 配置多数据源及事务管理1、主数据源配置，把Article的数据库整合进去，连接主数据源12345678910111213141516171819202122232425262728293031@Configuration@EnableConfigurationProperties@EnableAutoConfiguration@MapperScan(basePackages = "com.tomalen.springlanuch.generator.db1", sqlSessionTemplateRef = "primarySqlSessionTemplate")public class PrimaryDataSourceJTAConfig &#123; @Bean("primaryDataSource") @ConfigurationProperties(prefix = "primarydb") public DataSource primaryDataSource() &#123; return new AtomikosDataSourceBean(); &#125; @Bean("primarySqlSessionFactory") public SqlSessionFactory primarySqlSessionFactory(@Qualifier("primaryDataSource") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); //因为Mapper和Mapper.xml我放在同一个文件夹所以不用设资源路径 //bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml")); bean.setTypeAliasesPackage("com.tomalen.springlanuch.generator.db1"); //这里需要修改为你的扫描类路径 return bean.getObject(); &#125; @Bean("primarySqlSessionTemplate") public SqlSessionTemplate primarySqlSessionTemplate( @Qualifier("primarySqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 2、副数据源配置，把Message的数据库整合进去，连接副数据源123456789101112131415161718192021222324252627282930313233@Configuration@EnableConfigurationProperties@EnableAutoConfiguration@MapperScan(basePackages = "com.tomalen.springlanuch.generator.db2", sqlSessionTemplateRef = "secondarySqlSessionTemplate")public class SecondaryDataSourceJTAConfig &#123; @Bean("secondaryDataSource") @ConfigurationProperties(prefix = "secondarydb") @Primary public DataSource secondaryDataSource() &#123; return new AtomikosDataSourceBean(); &#125; @Bean("secondarySqlSessionFactory") @Primary public SqlSessionFactory secondarySqlSessionFactory(@Qualifier("secondaryDataSource") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); //bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml")); bean.setTypeAliasesPackage("com.tomalen.springlanuch.generator.db2"); return bean.getObject(); &#125; @Bean("secondarySqlSessionTemplate") @Primary public SqlSessionTemplate secondarySqlSessionTemplate( @Qualifier("secondarySqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; db1 和 db2 的目录结构 修改ArticleServiceImpl文件，将message插入进去123456789101112131415@Autowiredprivate ArticleMapper articleMapper;@Autowiredprivate MessageDao messageDao;@Overridepublic int saveArticle(Article article) &#123; //测试分布式管理，同时插入两个数据库 Message message = new Message(); message.setName("Kobe"); message.setContent("Shoot Three points!"); messageDao.insert(message); return articleMapper.insert(article);&#125; 具体测试使用postMan调试接口，有兴趣可以学习下~ 这里不赘述。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>jta-atomikos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Mybatis]]></title>
    <url>%2F2019%2F08%2F18%2FSpringBoot%E6%95%B4%E5%90%88Mybatis%2F</url>
    <content type="text"><![CDATA[SpringBoot整合Mybatis什么是Mybatis？MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。相对于Spring Data JPA来说，可以有非常直观的动态SQL，SQL可以写在XML里面，独立管理，动态SQL语法也容易书写与理解，易于对SQL的编写。 将Mybatis集成到Spring Boot1、引入maven依赖包123456789&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; 2、保证application.yml里面有数据库连接的配置12345678910111213141516171819#spring的相关配置spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 datasource: url: jdbc:mysql://localhost:3306/springboot username: root password: root driver-class-name: com.mysql.jdbc.Driver#Mybatis的Mapper的xml文件的路径mybatis: mapper-locations: classpath:/mybatis/mapper/*.xml#相关的日志配置logging: level: com.zimug.bootlaunch: debug 3、配置Mybatis的Mapper的扫描路径123456789@SpringBootApplication@MapperScan(basePackages = &#123;"com.tomalen.springlanuch.Dao"&#125;)public class SpringLanuchApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringLanuchApplication.class, args); &#125;&#125; 安装mybatis generator插件1、安装插件 如果遇到上不了网，就登录IntellJ IDEA 的官网下载插件-->http://plugins.jetbrains.com 2、在Settings–&gt;Tool–&gt;Mybatis Generator Plugin配置相关的路径 3、在IDEA上配置mySql 以上就是SpringBoot集成MyBatis。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 整合 spring Data JPA]]></title>
    <url>%2F2019%2F08%2F16%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Spring Boot 整合 spring Data JPA什么是 spring Data JPA？Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，底层使用了 Hibernate 的 JPA 技术实现，底层应用了Hibernate的具体配置。可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！ Spring Data JPA 可以极大提高开发效率。 将Spring Data JPA集成到Spring Boot1、使用maven依赖的方式，JPA依赖包和mysql驱动。12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2、修改application.yml12345678910111213spring: datasource: primary: jdbc-url: jdbc:mysql://localhost:3306/springboot username: root password: root driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update database: mysql show-sql: true create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 reate-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 基础核心用法实体类 VO实体类 : 可与关联相对应的对象，用于展示的实体类。 123456789101112131415@Data@Builder@AllArgsConstructor@NoArgsConstructorpublic class ArticleVO &#123; private Integer id; private String name; private String title; private String content; private Date createTime; private ArrayList&lt;Reader&gt; readers;` PO实体类：数据库持久层，与数据库中的数据相关联，属于平面实体类，不关联其他的对象。 1234567891011121314151617181920212223@Data@AllArgsConstructor@NoArgsConstructor@Builder@Entity@Table(name="article")public class ArticlePO &#123; @Id @GeneratedValue private Long id; @Column(nullable = false,length = 32) private String name; @Column(nullable = false, unique = true,length = 32) private String title; @Column(length = 512) private String content; private Date createTime;` 数据库操作接口：XxxRepository继承 JpaRepository&lt;T,ID&gt;为我们提供了各种针对单表的数据操作方法，用就完了。123//继承jpa，类型为Article，主键的类型为Longpublic interface ArticleRepository extends JpaRepository&lt;Article,Long&gt; &#123;&#125; service层接口:12345678910111213public interface ArticleRestService &#123; ArticleVO saveArticle(ArticleVO article); void deleteArticle(Long id); void updateArticle(ArticleVO article); ArticleVO getArticle(Long id); List&lt;ArticleVO&gt; getAll();&#125; Service层实现类：123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class ArticleJPARestService implements ArticleRestService &#123; @Resource private ArticleRepository articleRepository; @Resource private Mapper dozerMapper; public ArticleVO saveArticle( ArticleVO article) &#123; //把Vo实体类转为PO实体类 Article articlePO = dozerMapper.map(article,Article.class); articleRepository.save(articlePO); return article; &#125; @Override public void deleteArticle(Long id) &#123; articleRepository.deleteById(id); &#125; @Override public void updateArticle(ArticleVO article) &#123; Article articlePO = dozerMapper.map(article,Article.class); articleRepository.save(articlePO); &#125; @Override public ArticleVO getArticle(Long id) &#123; Optional&lt;Article&gt; article = articleRepository.findById(id); return dozerMapper.map(article.get(),ArticleVO.class); &#125; @Override public List&lt;ArticleVO&gt; getAll() &#123; List&lt;Article&gt; articleLis = articleRepository.findAll(); return DozerUtils.mapList(articleLis,ArticleVO.class); &#125;&#125; 总结总体而言，Spring Data JPA的用法相对简单，其自身带有的方法非常的多，用起来非常的便捷。但是相对于Mybatis来说不利于动态的sql查询，显得非常笨重。但是相对于hibernate来说简化了配置，底层也继承了hibernate的原理。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>spring Data JPA</tag>
      </tags>
  </entry>
</search>
