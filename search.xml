<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式-责任链模式]]></title>
    <url>%2F2020%2F04%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(9) 责任链模式责任链模式：这种模式为请求创建了一个接收者对象的链。这种模式对请求的发送者和接收者进行解耦。责任链模式通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，以此类推。职责链模式属于行为型模式。 原理类图 实现-OA系统审批系统(审批流)采购员采购学校的器材，进行分金额进行审批 如果采购金额&lt;3000,有部门来进行审批 如果采购金额&gt;3000,交由大学主任审批依据以上的分析，可以实现以下代码 源码RequestApprover.java 表示请求者1234567891011121314151617181920212223242526272829303132333435package top.zwhzzz.Design.ResponsebilityChain;/** * @ClassName RequsetApport * @Description TODO * @Author TomAlen * @Date 2020/4/11 21:06 * @Version 1.0 *///责任链模式，体现了请求者与被请求者相分离，体现了双链表的思想public class RequsetApport &#123; private String id; //表示要处理的编号 private float price = 0.0f; //要处理的金额 private String username; //要处理的名字 public RequsetApport(String id, float price, String username) &#123; this.id = id; this.price = price; this.username = username; &#125; //初始化getter方法 public String getId() &#123; return id; &#125; public float getPrice() &#123; return price; &#125; public String getUsername() &#123; return username; &#125;&#125; Approver.java1234567891011121314151617181920212223242526package top.zwhzzz.Design.ResponsebilityChain;/** * @ClassName Approver * @Description TODO * @Author TomAlen * @Date 2020/4/11 21:12 * @Version 1.0 */public abstract class Approver &#123; Approver approver; String name; //初始化 public Approver (String name) &#123; this.name = name; &#125; public void setName (Approver approver) &#123; this.approver = approver; &#125; //定义方法让子类进行继承 public abstract void getRequestApprover(RequsetApport requsetApport);&#125; DepartmentApprover.java123456789101112131415161718192021222324252627package top.zwhzzz.Design.ResponsebilityChain;/** * @ClassName DepartmentApprover * @Description TODO * @Author TomAlen * @Date 2020/4/11 21:18 * @Version 1.0 */public class DepartmentApprover extends Approver &#123; //继承父类的构造方法 public DepartmentApprover(String name) &#123; super(name); &#125; @Override public void getRequestApprover(RequsetApport requsetApport) &#123; //对金额的具体处理方法 if(requsetApport.getPrice() &lt; 3000) &#123; System.out.println( name + "处理了" + requsetApport.getUsername() + requsetApport.getPrice() + "元"); &#125;else &#123; //交给下一个处理人进行处理 approver.getRequestApprover(requsetApport); &#125; &#125;&#125; CollegeApprover.java123456789101112131415161718192021222324package top.zwhzzz.Design.ResponsebilityChain;/** * @ClassName CollegeApprover * @Description TODO * @Author TomAlen * @Date 2020/4/11 21:25 * @Version 1.0 */public class CollegeApprover extends Approver &#123; public CollegeApprover(String name) &#123; super(name); &#125; @Override public void getRequestApprover(RequsetApport requsetApport) &#123; if(requsetApport.getPrice() &gt; 3000) &#123; System.out.println(name + "处理了" + requsetApport.getUsername() + requsetApport.getPrice() + "元。"); &#125;else &#123; approver.getRequestApprover(requsetApport); &#125; &#125;&#125; 测试类Client123456789101112131415161718192021222324252627282930package top.zwhzzz.Design.ResponsebilityChain;import java.util.Random;import java.util.UUID;/** * @ClassName Client * @Description TODO * @Author TomAlen * @Date 2020/4/11 21:27 * @Version 1.0 */public class Client &#123; public static void main(String[] args) &#123; RequsetApport requsetApport = new RequsetApport(UUID.randomUUID().toString(), 5000, "碧哥"); //初始化具体的处理者 DepartmentApprover departmentApprover = new DepartmentApprover("主任"); CollegeApprover collegeApprover = new CollegeApprover("大学"); //设置下一个处理者 departmentApprover.setName(collegeApprover); collegeApprover.setName(departmentApprover); //处理金额 departmentApprover.getRequestApprover(requsetApport); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-代理模式]]></title>
    <url>%2F2020%2F04%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(8) 代理模式 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做是可以在原有目标对象的基础上增加额外的功能操作，扩展目标对象的功能。 代理模式有三种不同的形式：静态代理、动态代理（JDk代理、接口代理）以及Cglib代理，其中在这里主要介绍静态代理以及动态代理。 静态代理静态代理在使用中，需要定义接口和实现类，代理对象需要实现被代理的接口。 实例 创建一个IStudent接口 定义一个实现类Student，实现其内部方法 定义一个代理对象，集成IStudent接口，并将IStudent聚合进类中进行对实现类方法的调用 UML图解 源码IStudent.java 12345678910111213package top.zwhzzz.Design.Proxy;/** * @ClassName IStudent * @Description TODO * @Author TomAlen * @Date 2020/4/4 13:40 * @Version 1.0 */public interface IStudent &#123; void listen();&#125; Student.java 123456789101112131415package top.zwhzzz.Design.Proxy;/** * @ClassName student * @Description TODO * @Author TomAlen * @Date 2020/4/4 13:40 * @Version 1.0 */public class student implements IStudent&#123; @Override public void listen() &#123; System.out.println("学生开始上课！"); &#125;&#125; StudentProxy.java 12345678910111213141516171819202122232425package top.zwhzzz.Design.Proxy;/** * @ClassName studentProxy * @Description TODO * @Author TomAlen * @Date 2020/4/4 13:41 * @Version 1.0 */public class studentProxy implements IStudent&#123; private IStudent iStudent; public studentProxy(IStudent iStudent) &#123; this.iStudent = iStudent; &#125; @Override public void listen() &#123; System.out.println("代理模式开始"); //用接口调用实现类的方法 iStudent.listen(); System.out.println("提交"); &#125;&#125; Client.java 1234567891011121314151617package top.zwhzzz.Design.Proxy;/** * @ClassName Client * @Description TODO * @Author TomAlen * @Date 2020/4/4 14:00 * @Version 1.0 */public class Client &#123; public static void main(String[] args) &#123; student student = new student(); studentProxy studentProxy = new studentProxy(student); studentProxy.listen(); &#125;&#125; 输出 12345代理模式开始学生开始上课！提交Process finished with exit code 0 动态代理 代理对象不需要实现其接口，目标对象需要实现其接口，否则不能进行动态代理。 代理对象的生成使用了JDK的API，即通过反射进行对目标对象方法以及属性的获取，从而实现代理对象。 实例 创建一个ITeacher接口 定义目标类Teacher 定义代理对象TeacherProxy类，调用JDK的API进行反射操作。 UMl图解 源码ITeacher.java 12345678910111213package top.zwhzzz.Design.DematicProxy;/** * @ClassName ITeacher * @Description TODO * @Author TomAlen * @Date 2020/4/4 14:48 * @Version 1.0 */public interface ITeacher &#123; void teach(); void sayHello(String message);&#125; Teacher.java 1234567891011121314151617181920package top.zwhzzz.Design.DematicProxy;/** * @ClassName Teacher * @Description TODO * @Author TomAlen * @Date 2020/4/4 14:48 * @Version 1.0 */public class Teacher implements ITeacher &#123; @Override public void teach() &#123; System.out.println("老师教课..."); &#125; @Override public void sayHello(String message) &#123; System.out.println("老师说" + message); &#125;&#125; TeacherProxy.java 12345678910111213141516171819202122232425262728293031323334353637383940package top.zwhzzz.Design.DematicProxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/** * @ClassName TeacherProxy * @Description TODO * @Author TomAlen * @Date 2020/4/4 14:52 * @Version 1.0 */public class TeacherProxy &#123; private ITeacher iTeacher; //把接口实例化进代理构造器 public TeacherProxy(ITeacher iTeacher) &#123; this.iTeacher = iTeacher; &#125; //创建一个代理对象，里面根据反射机制获取对象的方法和属性 public Object getProxyInstance() &#123; return Proxy.newProxyInstance(iTeacher.getClass().getClassLoader(), iTeacher.getClass().getInterfaces(), //对传入对象进行处理 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("对象代理开始"); //反射机制获取被代理对象的方法 args=&gt;代表属性 Object invoke = method.invoke(iTeacher, args); //返回被代理的对象 return invoke; &#125; &#125;); &#125;&#125; Client.java 123456789101112131415161718192021package top.zwhzzz.Design.DematicProxy;/** * @ClassName Client * @Description TODO * @Author TomAlen * @Date 2020/4/4 15:02 * @Version 1.0 */public class Client &#123; public static void main(String[] args) &#123; //创建被代理对象 ITeacher teacher = new Teacher(); //创建代理对象并执行反射代理的方法。返回一个被代理的类 ITeacher proxyInstance = (ITeacher) new TeacherProxy(teacher).getProxyInstance();a //执行被代理对象的方法 proxyInstance.teach(); proxyInstance.sayHello("你好"); &#125;&#125; 输出 123456对象代理开始老师教课...对象代理开始老师说你好Process finished with exit code 0 通过学习了动态代理，发现框架中的灵魂很多都是动态代理以及反射机制，好好学习底层源码，加油！]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-桥接模式]]></title>
    <url>%2F2020%2F03%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(7) 桥接模式桥接模式是指将实现和抽象放在两个不同的类层次中，使两个层次可以独立改变。是一种结构型设计模式。 实现在用例中使用了手机的用例，定义了一个手机的品牌的接口，以及一个手机型的抽象类，将接口聚合到抽象类中。具体的类图如图所示。 源码Brand品牌接口12345678910111213141516package top.zwhzzz.Design.Bridge;/** * @ClassName Brand * @Description TODO * @Author TomAlen * @Date 2020/3/30 19:51 * @Version 1.0 *///定义一个手机品牌的接口public interface Brand &#123; //定义三个动作 void open(); void close(); void call();&#125; Xiaomi 手机实现类12345678910111213141516171819202122232425package top.zwhzzz.Design.Bridge;/** * @ClassName XiaoMi * @Description TODO * @Author TomAlen * @Date 2020/3/30 19:53 * @Version 1.0 */public class XiaoMi implements Brand &#123; @Override public void open() &#123; System.out.println("小米手机开机"); &#125; @Override public void close() &#123; System.out.println("小米手机关机"); &#125; @Override public void call() &#123; System.out.println("小米手机打电话"); &#125;&#125; Vivo 12345678910111213141516171819202122232425package top.zwhzzz.Design.Bridge;/** * @ClassName Vivo * @Description TODO * @Author TomAlen * @Date 2020/3/30 19:54 * @Version 1.0 */public class Vivo implements Brand &#123; @Override public void open() &#123; System.out.println("Vivo手机开机"); &#125; @Override public void close() &#123; System.out.println("Vivo手机关机"); &#125; @Override public void call() &#123; System.out.println("Vivo手机打电话"); &#125;&#125; Phone抽象类12345678910111213141516171819202122232425262728293031package top.zwhzzz.Design.Bridge;/** * @ClassName Phone * @Description TODO * @Author TomAlen * @Date 2020/3/30 19:55 * @Version 1.0 *///定义一个手机的抽象类，与品牌是聚合的关系，其定义的子类调用实现接口的方法public abstract class Phone &#123; private Brand brand; //利用构造器将接口调用 public Phone(Brand brand) &#123; this.brand = brand; &#125; //定义手机的动作 public void open() &#123; this.brand.open(); &#125; public void close() &#123; this.brand.close(); &#125; public void call() &#123; this.brand.call(); &#125;&#125; FoldedPhone实现类12345678910111213141516171819202122232425262728package top.zwhzzz.Design.Bridge;/** * @ClassName FoldedPhone * @Description TODO * @Author TomAlen * @Date 2020/3/30 20:00 * @Version 1.0 */public class FoldedPhone extends Phone &#123; //调用父类的方法 public FoldedPhone(Brand brand) &#123; super(brand); &#125; public void open() &#123; super.open(); &#125; public void close() &#123; super.close(); &#125; public void call() &#123; super.call(); &#125;&#125; 客户端测试类1234567891011121314151617181920package top.zwhzzz.Design.Bridge;/** * @ClassName Client * @Description TODO * @Author TomAlen * @Date 2020/3/30 20:04 * @Version 1.0 */public class Client &#123; public static void main(String[] args) &#123; //客户端进行测试 //利用抽象类子类进行对实现方法的实现 FoldedPhone foldedPhone = new FoldedPhone(new XiaoMi()); foldedPhone.open(); foldedPhone.close(); foldedPhone.call(); &#125;&#125; 输出12345小米手机开机小米手机关机小米手机打电话Process finished with exit code 0]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-适配器模式]]></title>
    <url>%2F2020%2F03%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(6) 适配器模式在2020年3月20日，是一个我终身难忘的日子，因为这是我脱单的日子，也是我女朋友24岁的生日，打算在明年的这个时候进行求婚，携起她的手共同走完余生。也就是基于这个原因，我最近飘了，没有继续学习设计模式，在3月初的时候打算在这个月底学完21种设计模式，但是，基于个人原因，没能完成初步计划，所以，在以后的学习中，要加倍努力才行。 一开始在菜鸟教程上学的设计模式，发现里面的内容晦涩难懂，所以这次是在B站的尚硅谷上学习的设计模式。发现里面的东西讲授的还是很不错的。 实现在学习过程中主要介绍了两种适配器模式，一种是类适配器模式（继承），一种是对象适配器模式（组合）。 设计实例在日常生活中，我们手机的充电需要在220V的电压进行转换成5V的电压，这就需要一个电压的转换适配器将电压进行转换。所以在这里定义了一个220V的电压类，定义一个方法，返回一个220V的电压。而后定义一个5V的接口。再定义一个适配器将220V的电压转换成5V的电压。再定义一个实体的Phone类进行充电，最后定义一个Client类进行测试。 源码类适配器模式（继承）IVolate5V接口 定义了一个5V电压的接口12345678910111213package top.zwhzzz.Design.AdapterPattern;/** * @ClassName IVolate5V * @Description TODO * @Author TomAlen * @Date 2020/3/27 20:46 * @Version 1.0 */public interface IVolate5V &#123; public int output5V ();&#125; Volate220V 定义一个220V的电压，返回一个220V的int类型的电压12345678910111213141516171819package top.zwhzzz.Design.AdapterPattern;/** * @ClassName Volate220V * @Description TODO * @Author TomAlen * @Date 2020/3/27 20:42 * @Version 1.0 *///适配器类 220Vpublic class Volate220V &#123; //返回一个220伏的电压 public int get220V() &#123; int volate = 220; System.out.println("此电压为" + volate + "伏！"); return volate; &#125;&#125; AdapterVolate 适配器 对220V的电压转换成5V的电压12345678910111213141516171819package top.zwhzzz.Design.AdapterPattern;/** * @ClassName Volate220V * @Description TODO * @Author TomAlen * @Date 2020/3/27 20:42 * @Version 1.0 *///适配器类 220Vpublic class Volate220V &#123; //返回一个220伏的电压 public int get220V() &#123; int volate = 220; System.out.println("此电压为" + volate + "伏！"); return volate; &#125;&#125; Phone 手机实体类 进行对手机的充电1234567891011121314151617181920package top.zwhzzz.Design.AdapterPattern;/** * @ClassName Phone * @Description TODO * @Author TomAlen * @Date 2020/3/27 20:51 * @Version 1.0 *///手机进行充电，进行5V电压的充电public class Phone &#123; //手机进行充电 public void charging(IVolate5V iVolate5V) &#123; if(iVolate5V.output5V() == 5) &#123; System.out.println("电压允许，可进行充电！"); &#125;else if (iVolate5V.output5V() &gt; 5)&#123; System.out.println("电压大于5V，不可充电"); &#125; &#125;&#125; Client 客户端类 进行对适配器模式进行测试123456789101112131415161718package top.zwhzzz.Design.AdapterPattern;/** * @ClassName Client * @Description TODO * @Author TomAlen * @Date 2020/3/27 21:00 * @Version 1.0 *///客户端 进行手机的充电public class Client &#123; public static void main(String[] args) &#123; System.out.println("=====类适配器===="); Phone phone = new Phone(); phone.charging(new AdapterVolate()); &#125;&#125; 类适配器是通过对类的继承进行适配的。 对象适配器模式（组合）对象适配器是通过进行对象在适配器中的组合，体现了组合复用原则，在适配器类中进行对220V电压类的定义，并在构造器中进行定义赋值。具体要修改的源码为 AdapterVolate1234567891011121314151617181920212223242526272829303132333435package top.zwhzzz.Design.AdapterPattern.IAdapterPattern;/** * @ClassName AdapterVolate * @Description TODO * @Author TomAlen * @Date 2020/3/27 20:49 * @Version 1.0 *///对象适配器，将对对象进行聚合的方式把对象拿到public class AdapterVolate implements IVolate5V &#123; private Volate220V volate220V; //将对象通过构造器的方式注入 public AdapterVolate(Volate220V volate220V) &#123; this.volate220V = volate220V; &#125; @Override public int output5V() &#123; int target = 0; //判断220V的适配器是否为空 if(volate220V != null) &#123; //调用父类方法进行传值 int src = volate220V.get220V(); System.out.println("对象适配器"); //对220伏的电压进行处理 target = src / 44; &#125; return target; &#125;&#125; Client123456789101112131415161718package top.zwhzzz.Design.AdapterPattern.IAdapterPattern;/** * @ClassName Client * @Description TODO * @Author TomAlen * @Date 2020/3/27 21:00 * @Version 1.0 *///客户端 进行手机的充电public class Client &#123; public static void main(String[] args) &#123; System.out.println("=====类适配器===="); Phone phone = new Phone(); phone.charging(new AdapterVolate(new Volate220V())); &#125;&#125; 这就是适配器模式的两种主要的方式，其中在SpringMVC源码中体现了适配器的这种思想，具体还没达到这种水平，就没去深入研究，等再积攒几年工作经验再看。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-原型模式]]></title>
    <url>%2F2020%2F03%2F17%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(5) 原型模式原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。该模式是实现了一种原型接口，该接口用于对象的克隆。 实现首先创建一个Shape类的原型接口，下一步创建一个缓存类ShapeCache，把该Shape的拓展类存入Hashtable中，，并在请求的时候返回他们的克隆。 源码1、创建一个原型的Shape接口,定义了ID、拓展类的type，并实现了Object类的Cloneable接口，重写了clone方法12345678910111213141516171819202122232425262728293031323334353637383940414243package top.zwhzzz.Design.PrototypePattern;/** * @ClassName Shape * @Description TODO * @Author TomAlen * @Date 2020/3/17 15:35 * @Version 1.0 *///原型模式public abstract class Shape implements Cloneable&#123; private String id; protected String type; //提供拓展类的draw方法 abstract void draw(); public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public String getType() &#123; return type; &#125; //重写Object类的clone方法 public Object clone() &#123; Object clone = null; try&#123; //使用父类的clone方法 clone = super.clone(); &#125;catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125; 2、创建Shape的拓展类，实例化对象调用超类的属性并赋值 Circle类 12345678910111213141516171819202122package top.zwhzzz.Design.PrototypePattern;/** * @ClassName Circle * @Description TODO * @Author TomAlen * @Date 2020/3/17 15:44 * @Version 1.0 *///Shape的实体拓展类public class Circle extends Shape&#123; public Circle() &#123; //构造器，初始化时往调用超类的属性type并赋值 type = "Circle"; &#125; @Override void draw() &#123; System.out.println("Circle =&gt; draw方法！"); &#125;&#125; Rectangle类 123456789101112131415161718192021package top.zwhzzz.Design.PrototypePattern;/** * @ClassName Rectangle * @Description TODO * @Author TomAlen * @Date 2020/3/17 15:48 * @Version 1.0 *///Shape的实体拓展类Rectanglepublic class Rectangle extends Shape&#123; public Rectangle() &#123; type = "Rectangle"; &#125; @Override void draw() &#123; System.out.println("Rectangle =&gt; draw!"); &#125;&#125; 3、创建一个缓存类ShapeCache，用于对Shape拓展对象的克隆1234567891011121314151617181920212223242526272829303132333435363738package top.zwhzzz.Design.PrototypePattern;import java.util.Hashtable;/** * @ClassName ShapeCache * @Description TODO * @Author TomAlen * @Date 2020/3/17 15:51 * @Version 1.0 *///Shape的缓存类，用于对Shape类的拓展public class ShapeCache &#123; //初始化一个HashTable的存储结构 private static Hashtable&lt;String, Shape&gt; shapeMap = new Hashtable&lt;&gt;(0); //根据形状的id进行获取相应的Shape public static Shape getShape(String shapeId) &#123; Shape shape = shapeMap.get(shapeId); //调用Shape类的clone方法进行复制，返回值为Object，需要进行类型的强制转换 return (Shape) shape.clone(); &#125; //对每种形状进行数据存储，用Hashtable的put方法。 public static void loadCache() &#123; //分别存入圆和长方形 Circle circle = new Circle(); circle.setId("1"); //用id进行区分，把对象存入集合中 shapeMap.put(circle.getId(), circle); Rectangle rectangle = new Rectangle(); rectangle.setId("2"); shapeMap.put(rectangle.getId(), rectangle); &#125;&#125; 4、测试类12345678910111213141516171819202122package top.zwhzzz.Design.PrototypePattern;/** * @ClassName PrototypeTest * @Description TODO * @Author TomAlen * @Date 2020/3/17 16:07 * @Version 1.0 */public class PrototypeTest &#123; public static void main(String[] args) &#123; //相当于数据库一样进行对数据的加载 ShapeCache.loadCache(); //代表圆 Shape cloneCircle = ShapeCache.getShape("1"); System.out.println("Shape =&gt; " + cloneCircle.getType()); Shape cloneRectangle = ShapeCache.getShape("2"); System.out.println("Shape =&gt; " + cloneRectangle.getType()); &#125;&#125; 输出1234Shape =&gt; CircleShape =&gt; RectangleProcess finished with exit code 0]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-建造者模式]]></title>
    <url>%2F2020%2F03%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(4) 建造者模式建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 实现建造者模式可以从点餐开始出发，我们可以这样理解，我们点餐可以点不同的套餐，根据自己的喜好来进行点餐。我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。具体的例子参见菜鸟教程。 源码步骤一、创建一个表示食物条目和食物包装的接口。Item.java 123456789101112131415package top.zwhzzz.Design.BuilderPattern;/** * @ClassName Items * @Description TODO * @Author TomAlen * @Date 2020/3/16 13:53 * @Version 1.0 *///接口，作为食物条目的公共的方法区public interface Items &#123; String name(); Packing packing(); float price();&#125; Packing.java 12345678910111213package top.zwhzzz.Design.BuilderPattern;/** * @ClassName Packing * @Description TODO * @Author TomAlen * @Date 2020/3/16 13:57 * @Version 1.0 *///接口，代表食物的包装的接口public interface Packing &#123; String pack();&#125; 步骤二、创建实现 Packing 接口的实体类。Wrapper.java 12345678910111213141516package top.zwhzzz.Design.BuilderPattern;/** * @ClassName Wrapper * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:00 * @Version 1.0 *///Packing包装的实现类 食物类public class Wrapper implements Packing &#123; @Override public String pack() &#123; return "wrapper"; &#125;&#125; Bottle.java 12345678910111213141516package top.zwhzzz.Design.BuilderPattern;/** * @ClassName Bottle * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:02 * @Version 1.0 *///Packing的实现类，表示瓶装的食品public class Bottle implements Packing &#123; @Override public String pack() &#123; return "bottle"; &#125;&#125; 步骤三、创建实现 Item 接口的抽象类，该类提供了默认的功能。Burger.java 1234567891011121314151617181920package top.zwhzzz.Design.BuilderPattern;/** * @ClassName Burger * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:07 * @Version 1.0 */public abstract class Burger implements Items&#123; @Override public Packing packing() &#123; //打包实例化食物的类 return new Wrapper(); &#125; //在抽象类中实现接口，可以直接加abstract修饰 @Override public abstract float price();&#125; ColdDrink.java 1234567891011121314151617package top.zwhzzz.Design.BuilderPattern;/** * @ClassName ColdDrink * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:16 * @Version 1.0 */public abstract class ColdDrink implements Items&#123; @Override public Packing packing() &#123; return new Bottle(); &#125; @Override public abstract float price();&#125; 步骤四、创建扩展了 Burger 和 ColdDrink 的实体类。VegBurger.java 12345678910111213141516171819202122package top.zwhzzz.Design.BuilderPattern;/** * @ClassName BuilderPattern * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:18 * @Version 1.0 *///拓展的实体类 汉堡类public class VegBurger extends Burger&#123; //实体扩展类继承了抽象类，重写的是没有在抽象类中实现的方法。 @Override public String name() &#123; return "Veg Burger"; &#125; @Override public float price() &#123; return 75.0f; &#125;&#125; ChickenBurger.java 1234567891011121314151617181920package top.zwhzzz.Design.BuilderPattern;/** * @ClassName ChickenBurger * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:24 * @Version 1.0 */public class ChickenBurger extends Burger&#123; @Override public String name() &#123; return "Chicken Burger"; &#125; @Override public float price() &#123; return 35.0f; &#125;&#125; Coke.java 1234567891011121314151617181920package top.zwhzzz.Design.BuilderPattern;/** * @ClassName Coke * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:30 * @Version 1.0 */public class Coke extends ColdDrink &#123; @Override public String name() &#123; return "coke"; &#125; @Override public float price() &#123; return 4.0f; &#125;&#125; Pepsi.java 1234567891011121314151617181920package top.zwhzzz.Design.BuilderPattern;/** * @ClassName Pepsi * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:30 * @Version 1.0 */public class Pepsi extends ColdDrink &#123; @Override public String name() &#123; return "pepsi"; &#125; @Override public float price() &#123; return 10.0f; &#125;&#125; 步骤五、创建一个 Meal 类，带有上面定义的 Item 对象。Meal.java 123456789101112131415161718192021222324252627282930313233343536373839package top.zwhzzz.Design.BuilderPattern;import java.util.ArrayList;import java.util.List;/** * @ClassName Meal * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:34 * @Version 1.0 */public class Meal &#123; //初始化一个item private List&lt;Items&gt; items = new ArrayList&lt;&gt;(0); public void addItem(Items item) &#123; items.add(item); &#125; public Float getPrices() &#123; float cost = 0.0f; for (Items item : items) &#123; //将item组合的价格相加 cost += item.price(); &#125; return cost; &#125; public void showItems()&#123; for (Items item : items) &#123; System.out.print("Item : "+item.name()); System.out.print(", Packing : "+item.packing().pack()); System.out.println(", Price : "+item.price()); &#125; &#125;&#125; 步骤六、创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。MealBuilder.java 123456789101112131415161718192021222324252627package top.zwhzzz.Design.BuilderPattern;/** * @ClassName MealBuilder * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:43 * @Version 1.0 *///管理每一个Meal类public class MealBuilder &#123; //两个套餐 public Meal prepareVegMeal() &#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNonVegMeal() &#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125; 步骤七、BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）。1234567891011121314151617181920212223242526package top.zwhzzz.Design.BuilderPattern;/** * @ClassName BuiderPatternDemo * @Description TODO * @Author TomAlen * @Date 2020/3/16 14:54 * @Version 1.0 *///用于测试建造者模式public class BuilderPatternDemo &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal meal = mealBuilder.prepareNonVegMeal(); System.out.println("VegBurger:=&gt;"); meal.showItems(); System.out.println("Cost:=&gt;" + meal.getPrices()); Meal novMeal = mealBuilder.prepareVegMeal(); System.out.println("Chicken:=&gt;"); novMeal.showItems(); System.out.println("Cost:=&gt;" + novMeal.getPrices()); &#125;&#125; 测试输出12345678910VegBurger:=&gt;Item : Veg Burger, Packing : wrapper, Price : 75.0Item : pepsi, Packing : bottle, Price : 10.0Cost:=&gt;85.0Chicken:=&gt;Item : Chicken Burger, Packing : wrapper, Price : 35.0Item : coke, Packing : bottle, Price : 4.0Cost:=&gt;39.0Process finished with exit code 0]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-判断子序列]]></title>
    <url>%2F2020%2F03%2F13%2F%E7%AE%97%E6%B3%95-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[算法 判断子序列算法描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。 示例 1: 1s = "abc", t = "ahbgdc" 返回 true. 示例 2: 1s = "axc", t = "ahbgdc" 返回 false. 来源：力扣（LeetCode） 个人思路当一个字符存在另一个字符串中，首先想到的是将字符串转化为字符组，再循环遍历，做出相应的处理。在这题中用到了indexOf这个方法，这个方法觉得设计的很妙。indexOf（char c，int i）意为从第i个索引开始搜寻指定字符c，如果未找到，就越界，返回-1。下面直接撸代码…. 实现代码12345678910111213141516class Solution &#123; public boolean isSubsequence(String s, String t) &#123; //s字符串转化为字符串数组 char[] arr = s.toCharArray(); int flag = -1; //对字符串数组进行循环 for (int i = 0; i &lt; arr.length; i ++ ) &#123; //用indexOf进行对字符串进行搜索，从j+1处为索引向下查找指定的字符arr[i]。 flag = t.indexOf(arr[i],flag + 1); if(flag == -1) &#123; return false; &#125; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-多数元素]]></title>
    <url>%2F2020%2F03%2F13%2F%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[算法 多数元素题目给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 12输入: [3,2,3]输出: 3 示例 2: 12输入: [2,2,1,1,1,2,2]输出: 2 来源：力扣（LeetCode） 个人思路对于此类题目，第一想到的是遍历循环数组中的每一个元素，然后统计每一个元素出现的次数。但是双层循环的时间复杂度和空间复杂度很大。所以这次采用的是哈希算法进行存储，利用键存储数字，用值存储出现的个数，这个思路只用了一层for循环。具体的代码如下： 实现代码1234567891011121314151617181920212223242526class Solution &#123; public int majorityElement(int[] nums) &#123; //使用HashMap进行对数进行统计。用Key值存储数字，用value存储次数 Map&lt;Integer,Integer&gt; counts = new HashMap&lt;&gt;(); for(int num : nums) &#123; //判断集合中是否含有此元素的键，即元素是否重复 if(!counts.containsKey(num)) &#123; counts.put(num,1); &#125;else&#123; //代表有值，在原来的基础上进行累加。 counts.put(num,counts.get(num) + 1); &#125; &#125; //初始化Entry Map.Entry&lt;Integer,Integer&gt; majority = null; //对counts进行编历，转化为Map.Entry接口 for(Map.Entry&lt;Integer,Integer&gt; entry : counts.entrySet()) &#123; //进行判断，利用打擂台法，依次进行替换。 if(majority == null || entry.getValue() &gt; majority.getValue()) &#123; majority = entry; &#125; &#125; //返回相应键 return majority.getKey(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-抽象工厂模式]]></title>
    <url>%2F2020%2F03%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(3) 抽象工厂今天是2020年3月12日，是一年一度的植树节，好像还是某个人的生日，但是我与她已经没有了交集。另外，2020是不平常的一年，全世界都笼罩在新冠肺炎的阴霾下了。也有可喜之处，今天我们江西省的新增还是累计确诊人数都清零了。抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建多个工厂的设计模式。属于创建型设计模式，即提供了一种创建对象的绝佳机会。接口负责创建一个相关对象的工厂， 每个生成的工厂都能按照工厂模式提供对象。个人理解是一个超级工厂管理多个工厂，根据类型获取相应的工厂，而获取的工厂根据对象的类型获取对象。 实现首先创建Shape以及Color的接口，再创建其实现类Circle、Rectangle以及类Red和Blue。下一步是创建抽象工厂类 AbstractFactory，接着定义工厂类ShapeFactory以及ColorFactory，这两个工厂类都是扩展了 AbstractFactory。接着定义生成类FactoryProduce，用于生成相应的工厂。具体的图实例如下图所示。 源码Shape接口123456789101112package top.zwhzzz.Design.AbstractFactory;/** * @ClassName Shape * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:02 * @Version 1.0 */public interface Shape &#123; void draw();&#125; Color接口123456789101112package top.zwhzzz.Design.AbstractFactory;/** * @ClassName Color * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:02 * @Version 1.0 */public interface Color &#123; void fill();&#125; Circle类123456789101112131415package top.zwhzzz.Design.AbstractFactory;/** * @ClassName Circle * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:09 * @Version 1.0 */public class Circle implements Shape&#123; @Override public void draw() &#123; System.out.println("调用方法：Shape:=&gt;Circle"); &#125;&#125; Rectangle类123456789101112131415package top.zwhzzz.Design.AbstractFactory;/** * @ClassName Rectangle * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:09 * @Version 1.0 */public class Rectangle implements Shape&#123; @Override public void draw() &#123; System.out.println("调用方法：Shape:=&gt;Rectangle"); &#125;&#125; Red 类123456789101112131415package top.zwhzzz.Design.AbstractFactory;/** * @ClassName Red * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:18 * @Version 1.0 */public class Red implements Color &#123; @Override public void fill() &#123; System.out.println("调用Color: =&gt; Red"); &#125;&#125; Blue类123456789101112131415package top.zwhzzz.Design.AbstractFactory;/** * @ClassName Blue * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:18 * @Version 1.0 */public class Blue implements Color&#123; @Override public void fill() &#123; System.out.println("调用Color: =&gt; Blue"); &#125;&#125; 抽象工厂类AbstractFactory1234567891011121314package top.zwhzzz.Design.AbstractFactory;/** * @ClassName AbstractFactory * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:38 * @Version 1.0 */public abstract class AbstractFactory &#123; //定义两个静态方法 public abstract Color getColor(String color); public abstract Shape getShape(String shape) ;&#125; Shape工厂类ShapeFactory1234567891011121314151617181920212223242526272829package top.zwhzzz.Design.AbstractFactory;/** * @ClassName ShapeFactory * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:37 * @Version 1.0 */public class ShapeFactory extends AbstractFactory&#123; @Override public Color getColor(String color) &#123; return null; &#125; @Override public Shape getShape(String shape) &#123; if(shape == null) &#123; return null; &#125; if(shape.equalsIgnoreCase("Circle")) &#123; return new Circle(); &#125;else if(shape.equalsIgnoreCase("Rectangle")) &#123; return new Rectangle(); &#125; return null; &#125;&#125; Color工厂类ColorFactory12345678910111213141516171819202122232425262728package top.zwhzzz.Design.AbstractFactory;/** * @ClassName ColorFactory * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:38 * @Version 1.0 */public class ColorFactory extends AbstractFactory&#123; @Override public Color getColor(String color) &#123; if(color == null) &#123; return null; &#125; if(color.equalsIgnoreCase("Red")) &#123; return new Red(); &#125;else if (color.equalsIgnoreCase("Blue"))&#123; return new Blue(); &#125; return null; &#125; @Override public Shape getShape(String shape) &#123; return null; &#125;&#125; 工厂生成类FactoryProducer12345678910111213141516171819202122232425package top.zwhzzz.Design.AbstractFactory;/** * @ClassName FactoryProducer * @Description TODO * @Author TomAlen * @Date 2020/3/12 15:55 * @Version 1.0 *///根据传递的形状以及颜色获取相应的工厂类 public class FactoryProducer &#123; //静态方法，不用实例化，根据传入的值获取相应的工厂 public static AbstractFactory getFactory(String factory) &#123; if(factory == null) &#123; return null; &#125; if(factory.equalsIgnoreCase("Color")) &#123; return new ColorFactory(); &#125;else if(factory.equalsIgnoreCase("Shape")) &#123; return new ShapeFactory(); &#125; return null; &#125;&#125; 测试类FactoryTest123456789101112131415161718192021222324package top.zwhzzz.Design.AbstractFactory;/** * @ClassName FactoryTest * @Description TODO * @Author TomAlen * @Date 2020/3/12 16:12 * @Version 1.0 */public class FactoryTest &#123; public static void main(String[] args) &#123; //获取Shape工厂 AbstractFactory shape = FactoryProducer.getFactory("Shape"); //获取圆的实例 Shape cicle = shape.getShape("Circle"); cicle.draw(); //获取颜色的抽象工厂，再根据抽象工厂获取颜色实例。 AbstractFactory color = FactoryProducer.getFactory("Color"); Color Red = color.getColor("Red"); Red.fill(); &#125;&#125; 测试输出由于篇幅有限，就没有多个测试实例 1234调用方法：Shape:=&gt;Circle调用Color: =&gt; RedProcess finished with exit code 0]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-字母大小写全排列]]></title>
    <url>%2F2020%2F03%2F11%2F%E7%AE%97%E6%B3%95-%C2%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[算法-字母大小写全排列题目给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 示例: 12345678输入: S = "a1b2"输出: ["a1b2", "a1B2", "A1b2", "A1B2"]输入: S = "3z4"输出: ["3z4", "3Z4"]输入: S = "12345"输出: ["12345"] 注意： 12S 的长度不超过12。S 仅由数字和字母组成。 来源：力扣（LeetCode） 个人思路看到字符串的字符转化为一个新的字符串，首先想到的是把字符串转化为字符数组一次遍历，再将遍历的字符串做出相应的处理，最后存入集合中。 看了官方给的答案，研究了第一种解法，写的是解法是用法的是递归的方法，但是我研究了它里面的代码以及思想，并不是用到的是递归，而是遍历的思想，也就是暴力求解。 给出的解法是初始化一个集合ans，对其进行更新，比如谁S=”ab”，那ans=””，更新后ans=[“a”,”A”],ans=[“ab”,”Ab”,”aB”,”AB”]根据以上的思路，可以先定义一个集合，然后对字符串进行遍历，判断是否属于字母。如果属于字母，就对其进行添加进集合，并对其进行追加小写和大写字母。不是字母就直接添加就可以了。 源码 1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;String&gt; letterCasePermutation(String S) &#123; //初始化集合ans,类型用StringBuilder进行存储 List&lt;StringBuilder&gt; ans = new ArrayList&lt;&gt;(); ans.add(new StringBuilder()); //对字符串转化成字符串数组，进行判断 for(char c : S.toCharArray()) &#123; int n = ans.size(); //判断字符是否为字母 if(Character.isLetter(c)) &#123; //对字符进行循环 for(int i = 0; i &lt; n; ++i) &#123; //添加初始化集合ans的长度 ans.add(new StringBuilder(ans.get(i))); //往后面追加大写和小写字母 ans.get(i).append(Character.toLowerCase(c)); ans.get(i+1).append(Character.toUpperCase(c)); &#125; &#125; //代表数字，往后面添加就可以。 else&#123; for(int i = 0; i &lt; n; ++ i) &#123; ans.get(i).append(c); &#125; &#125; &#125; //将集合的字符转为String类型 List&lt;String&gt; result = new ArrayList&lt;&gt;(); for(StringBuilder an : ans) &#123; result.add(an.toString()); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式]]></title>
    <url>%2F2020%2F03%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(2) 工厂模式工厂模式工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。属于创建型设计模式，提供了一种最佳的创建对象的最佳方式。 含义定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建的过程延迟到子类进行。 实现首先创建一个Shape接口和创建实现Shape的实体类，下一步是定义一个工厂类ShapeFactory，和测试工厂类FactoryTest来演示获取对象的过程，它将向ShapeFactory传递消息，获取它所需要的对象类型。 源码Shape接口12345678910111213package top.zwhzzz.Design.Factory;/** * @ClassName Shape * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:13 * @Version 1.0 *///定义一个接口类public interface Shape &#123; void draw();&#125; Circle类1234567891011121314151617package top.zwhzzz.Design.Factory;/** * @ClassName Circle * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:15 * @Version 1.0 *///实体类Circlepublic class Circle implements Shape&#123; @Override public void draw() &#123; System.out.println("调用方法：=&gt; Circle"); &#125;&#125; Rectangle实体类12345678910111213141516package top.zwhzzz.Design.Factory;/** * @ClassName Rectangle * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:18 * @Version 1.0 *///实体类Rectanglepublic class Rectangle implements Shape&#123; @Override public void draw() &#123; System.out.println("调用方法：=&gt; Rectangle"); &#125;&#125; Square实体类12345678910111213141516package top.zwhzzz.Design.Factory;/** * @ClassName Square * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:18 * @Version 1.0 *///实体类Squarepublic class Square implements Shape&#123; @Override public void draw() &#123; System.out.println("调用方法：=&gt; Square"); &#125;&#125; ShapeFactory工厂类1234567891011121314151617181920212223242526272829303132package top.zwhzzz.Design.Factory;/** * @ClassName ShapeFactory * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:31 * @Version 1.0 *///形状工厂，生成基于给定信息的实体类的对象名称public class ShapeFactory &#123; //获取形状的类型的对象 public Shape getShape(String shapeType) &#123; if(shapeType == null) &#123; return null; &#125; //Circle if(shapeType.equalsIgnoreCase("Circle")) &#123; return new Circle(); &#125; //Rectangle if(shapeType.equalsIgnoreCase("Rectangle")) &#123; return new Rectangle(); &#125; //Square if(shapeType.equalsIgnoreCase("Square")) &#123; return new Square(); &#125; return null; &#125;&#125; FactoryTest测试类12345678910111213141516171819202122232425262728package top.zwhzzz.Design.Factory;/** * @ClassName FactoryTest * @Description TODO * @Author TomAlen * @Date 2020/3/10 16:46 * @Version 1.0 *///测试工厂类public class FactoryTest &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //Circle ==&gt;利用工厂对Circle进行实例化，获取对象，调用方法。 Shape circle = shapeFactory.getShape("Circle"); circle.draw(); //Rectangle ==&gt;获取Rectangle对象，利用接口调用实现的方法 Shape rectangle = shapeFactory.getShape("Rectangle"); rectangle.draw(); //square ==&gt;获取square对象，利用接口调用实现的方法 Shape square = shapeFactory.getShape("Square"); square.draw(); &#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--单例模式]]></title>
    <url>%2F2020%2F03%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(1) 单例模式单例模式的概念单例模式是比较常见的一种设计模式，设计的目的是保证一个类有一个实例，而且自行实例化并向整个系统提供这个实例，避免频繁创建对象，可以提高对象的复用性，节约内存。 类加载(classLoader)的顺序类加载(classLoader)机制一本遵循以下几种顺序。 先执行父类的静态代码块和静态变量初始化 执行子类的静态代码块和静态变量初始化 执行父类的实例变量初始化 执行父类的构造函数 执行子类的实例变量初始化 执行子类的构造函数 特别注意，加载类的过程是线程私有的，别的线程无法进入。 两种实现方式–懒汉和饿汉在单例模式的实现过程中，一般分为懒汉式和饿汉式。懒汉式：在类加载时不完成初始化，等到第一次使用时才实例化，实现的是懒加载模式。饿汉式：在类加载时就完成了初始化，所以类加载比较慢，获取对象的速度却比较快。 源码饿汉式12345678910111213141516171819202122232425package top.zwhzzz.Design.Singletone;/** * @ClassName SingletonErHan 单例模式==&gt;恶汉模式 * @Description TODO * @Author TomAlen * @Date 2020/3/9 15:14 * @Version 1.0 *///恶汉式的设计模式：在类加载的过程中进行了实例化， 避免了多线程的的同步问题。public class SingletonErHan &#123; private static final SingletonErHan singletonErHan = new SingletonErHan(); //无参构造器 public SingletonErHan() &#123; &#125; //getter方法，获取实例化的singletonErHan public static SingletonErHan getSingletonErHan() &#123; return singletonErHan; &#125;&#125; 懒汉式12345678910111213141516171819202122232425262728package top.zwhzzz.Design.Singletone;/** * @ClassName SingletonLanHan 单例模式==&gt;懒汉模式 * @Description TODO * @Author TomAlen * @Date 2020/3/9 15:15 * @Version 1.0 *///懒汉式单例模式，在类实例化的时候进行懒加载，添加了synchronized关键字，解决了线程不安全的问题。public class SingletonLanHan &#123; private static SingletonLanHan singletonLanHan = null; public SingletonLanHan() &#123; &#125; //加锁机制，如果有两个线程同时访问，一个进入线程中，另一个则在等待，解决了线程不安全的问题。但是缺点也很明显，因为synchronized是修饰整个方法，每个线程访问都要进行同步，会造成资源的浪费。 public static synchronized SingletonLanHan getSingletonLanHan() &#123; if(singletonLanHan == null) &#123; singletonLanHan = new SingletonLanHan(); &#125; return singletonLanHan; &#125;&#125; 双层检查懒汉式123456789101112131415161718192021222324252627282930package top.zwhzzz.Design.Singletone;/** * @ClassName SingletonLanHanDouble * @Description TODO * @Author TomAlen * @Date 2020/3/9 17:09 * @Version 1.0 *///双重检查懒汉式public class SingletonLanHanDouble &#123; private static volatile SingletonLanHanDouble instance= null; public SingletonLanHanDouble() &#123; &#125; //synchronized关键字加在代码块上了，而不是在方法上，可以提高效率。 public static SingletonLanHanDouble getInstance() &#123; if(instance == null) &#123; synchronized (SingletonLanHanDouble.class) &#123; if(instance == null) &#123; instance = new SingletonLanHanDouble(); &#125; &#125; &#125; return instance; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法--数组中重复的数]]></title>
    <url>%2F2020%2F03%2F09%2F%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%2F</url>
    <content type="text"><![CDATA[算法–数组中重复的数算法描述在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制： 12 &lt;= n &lt;= 100000 来源：力扣（LeetCode） 个人思路因为是要在数组中找出重复的数,所以第一思路就是用Set集合进行存储，而要找出任意一个数即可，所以只要出现了这个数，就可以跳出循环了。 1 初始化一个Set集合，存储不重复的元素 2 初始化一个重复的数字repeat = 0 3 遍历数组 如果set存储了重复的元素，就添加不成功，跳出循环，将重复的数字赋值给repeat 具体代码123456789101112131415class Solution &#123; public int findRepeatNumber(int[] nums) &#123; //思路：初始化一个Set集合，存储不重复的数字 Set&lt;Integer&gt; sets = new HashSet&lt;&gt;(); int repates = 0; //遍历数组 for (int num : nums) &#123; if(!sets.add(num)) &#123; repates = num; break; &#125; &#125; return repates; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN、APN]]></title>
    <url>%2F2020%2F03%2F06%2FVPN%E3%80%81APN%2F</url>
    <content type="text"><![CDATA[VPN和APN的概念最近项目经理给了我一个任务，就是去了解下VPN、APN技术，作为计算机网络的菜鸡，感觉这是一个艰巨的任务，但是作为项目中的一员，还得去干~ VPNVPN全名为虚拟专用网络，属于远程访问技术，简单的说就是利用公用网络架设私有网络。可以这样理解，利用公共的网通过VPN这个桥梁搭建自己的私有网络，其中也有这样一层说法，就是翻墙。具体在win10的操作流程为： 打开“网络和Intenet设置”，选择VPN 添加VPN连接 填写相关的参数 服务器或地址填写要访问的内网数据的ip地址 用户名和密码则是要访问的公司给的VPN账号 APNAPN是一种网络接入技术，通过手机上网设置的一个参数，决定了手机通过哪种接入方式来访问网络。具体的做法如下： 1：打开手机设置 2：点击”双卡和移动网络” 3：点击”中国移动/联通/电信” 4：点击”接入点名称(APN)” 5：点击新建APN，输入相应的设置后保存即可访问你自己设置的接入点来访问网络。]]></content>
      <tags>
        <tag>VPN</tag>
        <tag>APN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的常用操作]]></title>
    <url>%2F2020%2F03%2F05%2FGit%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Git的常用操作什么是GitGit是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。在很多的公司里都在使用这种版本控制工具，可以有效的对代码进行管理，能有效的开展协同办公，使公司员工能各司其职，便于公司的开发和项目管理。 Git的常规操作这里简单介绍一下本人常用的Git操作。 1、查看本次操作属于哪个分支上 1git branch 2、新建一个新的分支xxx 1git checkout -b xxx 3、查看本地库的状态 1git status 4、将代码添加到暂存区 1git add . 5、将代码提交到本地库，将本次提交备注为xxxxx 1git commit -m "xxxxx" 6、将代码提交到远程仓库 12345&lt;!-- 第一次提交 --&gt;git push -u origin xxx &lt;!-- 第一次提交后 --&gt;git push 7、更新本地代码 1git pull 8、将分支xxx的代码合并到master分支上,首先得切换到主分支master上，将分支xxx的代码合并，最后提交到远程仓库。 123git checkout mastergit merge xxxgit push 今天是3月5日，是2020年的第一篇博客，我承认自己最近有点懒，所以要走出舒适圈，对自己进行充电学习，特别是在这个疫情大环境下，如果不想被社会淘汰，那就好好努力吧！]]></content>
      <categories>
        <category>版本控制</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2019%2F09%2F02%2F%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[联系方式 手机：15279615192 Email：zwhzzz1127@gmail.com 微信号：zwh15279615192 QQ： 1127568664 个人信息 姓名：钟炜宏 性别：男 年龄：23 学历：本科 工作经验：1年 毕业院校：九江学院 所学专业：信息管理与信息系统 所获证书：计算机二级Java、CET-4、软件设计师 技术博客：https://www.zwhzzz.top 期望职位：Java工程师 期望薪资：10k 期望城市：深圳 个人介绍本人毕业于九江学院，在校期间主要对Java方面的进行了学习，大四期间在广州奥格智能科技有限公司南昌分公司进行实习，在此期间学会了很多学校里学不到的东西。本人的熟悉运用SpringBoot、SSM框架，了解前端的Vue+ElementUI、JQuery以及BootStrap框架，熟悉掌握数据库基本理论，熟练MySQL的使用。本人对编程具有浓厚的兴趣！ 工作经验 项目经历毕业设计-基于SSM的酒店管理系统的设计与实现 2019年07月 这是一个基于SSM框架的酒店管理系统，前端采用easyUI框架，使用mysql数据库进行后台数据库的搭建，应用ECharts工具完成营业额的数据可视化操作。主要的功能有后台用户信息管理、后台用户角色管理、后台用户权限分配、菜单管理、楼层管理、房型管理、房间管理、客户管理、预定订单管理、入住管理、统计分析管理、日志管理等功能。具体的项目请见 https://github.com/TomAlen/tomalen1.github.io.git 基于SSM的学生管理系统的设计与实现 2019年03月 一个基于SSM框架的简单的学生管理系统，可以对管理员、学生、教师、班级以及年级的简单的增删改查操作，涉及到模糊查询、分页查询。运用了权限分配的知识对管理员、学生、教师三者进行权限分配。前端用的是easy-ui框架,后台使用mysql数据库进行后台的数据搭建。具体的项目请见 https://github.com/TomAlen/tomalen1.github.io.git 招聘信息系统的设计与实现 2018年09月 招聘信息系统是本人写的第一个基于SSM框架的系统，后端采用 spring+spring-mvc+mybatis框架进行设计和编写，数据库采用mysql数据库。前端采用的是layui框架。其主要功能有对简历的增删改查、对用户信息的增删改查、对招聘信息的维护和发布。]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>简历</tag>
        <tag>个人历程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot对Github授权登录操作]]></title>
    <url>%2F2019%2F08%2F26%2FSpringBoot%E5%AF%B9Github%E6%8E%88%E6%9D%83%E7%99%BB%E5%BD%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[SpringBoot对Github授权登录操作首先了解github授权的API流程，具体网址登陆github的官网https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/创建OAuth应用程序，在githubAPI上有具体的操作。具体见https://developer.github.com/apps/building-oauth-apps/creating-an-oauth-app/ 有详细的操作步骤。注册完如图所示： 具体的操作流程 社区发送authorize Github回调redirect_url给社区 社区发送access_token携带code Github返回access_token 社区发送User携带access_token Github返回user信息给社区 存取数据。更新登录状态 把从scope获取到的user信息返回给user 代码实现授权登录1、先定义一个AuthorizeController，把从后端获取的user回调信息返回到主页面 1234567891011121314151617181920212223242526@Autowiredprivate GithubProvider githubProvider;/** * 授权github返回主页面 * @param code * @param state * @return */@GetMapping("/callback")public String callback(@RequestParam(name = "code")String code, @RequestParam(name = "state")String state) &#123; //实例化AccessTokenDTO AccessTokenDTO accessTokenDTO = new AccessTokenDTO(); accessTokenDTO.setCode(code); accessTokenDTO.setRedirect_uri("http://localhost:8080/callback"); accessTokenDTO.setClient_id("自己注册的client_id"); accessTokenDTO.setState(state); accessTokenDTO.setClient_secret("自己注册的client_secret"); String accessToken = githubProvider.getAccessToken(accessTokenDTO); //得到Github User信息 GithubUser githubUser = githubProvider.githubUser(accessToken); System.out.println(githubUser.getName()); return "index";&#125; 2、定义DTO数据传输模型，对要转换的数据进行操作。 对获取的AccessToken进行定义 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class AccessTokenDTO &#123; //githubAPI第二步： GitHub将用户重定向回您的网站 返回的类型参数 private String client_id; private String client_secret; private String code; private String redirect_uri; private String state; public String getClient_id() &#123; return client_id; &#125; public void setClient_id(String client_id) &#123; this.client_id = client_id; &#125; public String getClient_secret() &#123; return client_secret; &#125; public void setClient_secret(String client_secret) &#123; this.client_secret = client_secret; &#125; public String getCode() &#123; return code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getRedirect_uri() &#123; return redirect_uri; &#125; public void setRedirect_uri(String redirect_uri) &#123; this.redirect_uri = redirect_uri; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125;&#125; github获取的用户模型 123456789101112131415161718192021222324252627282930313233public class GithubUser &#123; //github的姓名 private String name; //id private Long id; //描述 private String bio; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getBio() &#123; return bio; &#125; public void setBio(String bio) &#123; this.bio = bio; &#125;&#125; 3、定义一个提供者，具体作用为相当于一个中间件，对获取的数据进行操作。其中涉及了okHttp的测试工具，具体可见okHttp官网进行学习：https://square.github.io/okhttp/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Componentpublic class GithubProvider &#123; /** * 第一步、 * 得到AccessToken * @param accessTokenDTO * @return */ public String getAccessToken(AccessTokenDTO accessTokenDTO)&#123; MediaType mediaType = MediaType.get("application/json; charset=utf-8"); OkHttpClient client = new OkHttpClient(); //把MediaType对象解析成srting类型 RequestBody body = RequestBody.create(mediaType,JSON.toJSONString(accessTokenDTO)); Request request = new Request.Builder() //github重定向个人网站url，交换access_token .url("https://github.com/login/oauth/access_token") .post(body) .build(); try (Response response = client.newCall(request).execute()) &#123; //得到返回的access_token String string = response.body().string(); //拆分得到access_token //先以&amp;号拆分，后以=号拆分 String[] split = string.split("&amp;"); String tokenString = split[0]; String access_token = tokenString.split("=")[1]; System.out.println(string); return access_token; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125; /** * 把得到的accessToken传入User对象，得到user对象的信息 * 得到返回的Scope的User信息 * 定义的githubUser有三个属性 * @param accessToken * @return */ public GithubUser githubUser(String accessToken) &#123; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("https://api.github.com/user?access_token=" + accessToken) .build(); try&#123; Response response = client.newCall(request).execute(); String string = response.body().string(); //把得到的从url得到的json数据解析成GithubUser类对象 GithubUser githubUser = JSON.parseObject(string, GithubUser.class); return githubUser; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return null; &#125;&#125; 具体的操作就是这样。写的不怎么好，原理大致就是这样。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Github - SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合MongoDB]]></title>
    <url>%2F2019%2F08%2F20%2FSpringBoot%E6%95%B4%E5%90%88MongoDB%2F</url>
    <content type="text"><![CDATA[SpringBoot整合MongoDB那么什么是MongoDB？定义MongoDB 是一个基于分布式文件存储的数据库。旨在为WEB应用提供可扩展的高性能数据存储解决方案。MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 MongoDB（来自于英文单词“Humongous”，中文含义为“庞大”）是可以应用于各种规模的企业、各个行业以及各类应用程序的开源数据库。作为一个适用于敏捷开发的数据库，MongoDB的数据模式可以随着应用程序的发展而灵活地更新。与此同时，它也为开发人员 提供了传统数据库的功能：二级索引，完整的查询系统以及严格一致性等等。 MongoDB能够使企业更加具有敏捷性和可扩展性，各种规模的企业都可以通过使用MongoDB来创建新的应用，提高与客户之间的工作效率，加快产品上市时间，以及降低企业成本。 MongoDB是专为可扩展性，高性能和高可用性而设计的数据库。 它可以从单服务器部署扩展到大型、复杂的多数据中心架构。利用内存计算的优势，MongoDB能够提供高性能的数据读写操作。 MongoDB的本地复制和自动故障转移功能使您的应用程序具有企业级的可靠性和操作灵活性。 简单来说，MongoDB是一个基于分布式文件存储的数据库，它是一个介于关系数据库和非关系数据库之间的产品，其主要目标是在键/值存储方式（提供了高性能和高度伸缩性）和传统的RDBMS系统（具有丰富的功能）之间架起一座桥梁，它集两者的优势于一身。 MongoDB支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型，也因为他的存储格式也使得它所存储的数据在Nodejs程序应用中使用非常流畅。 传统的关系数据库一般由数据库（database）、表（table）、记录（record）三个层次概念组成，MongoDB是由数据库（database）、集合（collection）、文档对象（document）三个层次组成。MongoDB对于关系型数据库里的表，但是集合中没有列、行和关系概念，这体现了模式自由的特点。 MongoDB中的一条记录就是一个文档，是一个数据结构，由字段和值对组成。MongoDB文档与JSON对象类似。字段的值有可能包括其它文档、数组以及文档数组。MongoDB支持OS X、Linux及Windows等操作系统，并提供了Python，PHP，Ruby，Java及C++语言的驱动程序，社区中也提供了对Erlang及.NET等平台的驱动程序 MongoDB使用原理是什么?所谓“面向集合”（Collection-Oriented），意思是数据被分组存储在数据集中，被称为一个集合（Collection)。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档。集合的概念类似关系型数据库（RDBMS）里的表（table），不同的是它不需要定义任何模式（schema)。Nytro MegaRAID技术中的闪存高速缓存算法，能够快速识别数据库内大数据集中的热数据，提供一致的性能改进。模式自由（schema-free)，意味着对于存储在mongodb数据库中的文件，我们不需要知道它的任何结构定义。如果需要的话，你完全可以把不同结构的文件存储在同一个数据库里。存储在集合中的文档，被存储为键-值对的形式。键用于唯一标识一个文档，为字符串类型，而值则可以是各种复杂的文件类型。我们称这种存储形式为BSON（Binary Serialized Document Format）。 核心NoSql的定义NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。适用于分布式计算场景 MongoDB的下载安装下载地址：https://fastdl.mongodb.org/win32/mongodb-win32-x86_64-2012plus-4.2.0-signed.msi 下载的网速有点慢，毕竟是国外的网站。windows下安装采用傻瓜式安装，直接下一步就行啦~ springBoot集成1、maven下加入依赖包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;&lt;/dependency&gt; 2、application.yml配置连接12345spring: data: mongodb: uri: mongodb://test:123@localhost:27017/testdb 3、在项目入口启动类上面加一个注解。开启Mongodb审计功能.1@EnableMongoAuditing 4、数据库层操作Dao1234public interface ArticleDao extends MongoRepository&lt;Article,String&gt; &#123; //支持关键字查询，和JPA的用法一样 Article findByAuthor(String author);&#125; 以上就是SpringBoot整合MongoDB的做法。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis集成atomikos实现分布式事务]]></title>
    <url>%2F2019%2F08%2F19%2Fmybatis%E9%9B%86%E6%88%90atomikos%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[mybatis集成atomikos实现分布式事务什么是jta-atomikos以及分布式事务？Atomikos 是一个为Java平台提供增值服务的并且开源类事务管理器。分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简而言之，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。 整合jta-atomikos1、引入依赖包1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jta-atomikos&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置yml文件，配置双数据源1234567891011121314151617181920212223primarydb: uniqueResourceName: primary xaDataSourceClassName: com.mysql.jdbc.jdbc2.optional.MysqlXADataSource xaProperties: url: jdbc:mysql://localhost:3306/springboot user: root password: root exclusiveConnectionMode: true minPoolSize: 3 maxPoolSize: 10 testQuery: SELECT 1 from dual #由于采用HikiriCP，用于检测数据库连接是否存活。secondarydb: uniqueResourceName: secondary xaDataSourceClassName: com.mysql.jdbc.jdbc2.optional.MysqlXADataSource xaProperties: url: jdbc:mysql://localhost:3306/springboot1 user: root password: root exclusiveConnectionMode: true minPoolSize: 3 maxPoolSize: 10 testQuery: SELECT 1 from dual #由于采用HikiriCP，用于检测数据库连接是否存活。 配置多数据源及事务管理1、主数据源配置，把Article的数据库整合进去，连接主数据源12345678910111213141516171819202122232425262728293031@Configuration@EnableConfigurationProperties@EnableAutoConfiguration@MapperScan(basePackages = "com.tomalen.springlanuch.generator.db1", sqlSessionTemplateRef = "primarySqlSessionTemplate")public class PrimaryDataSourceJTAConfig &#123; @Bean("primaryDataSource") @ConfigurationProperties(prefix = "primarydb") public DataSource primaryDataSource() &#123; return new AtomikosDataSourceBean(); &#125; @Bean("primarySqlSessionFactory") public SqlSessionFactory primarySqlSessionFactory(@Qualifier("primaryDataSource") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); //因为Mapper和Mapper.xml我放在同一个文件夹所以不用设资源路径 //bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml")); bean.setTypeAliasesPackage("com.tomalen.springlanuch.generator.db1"); //这里需要修改为你的扫描类路径 return bean.getObject(); &#125; @Bean("primarySqlSessionTemplate") public SqlSessionTemplate primarySqlSessionTemplate( @Qualifier("primarySqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 2、副数据源配置，把Message的数据库整合进去，连接副数据源123456789101112131415161718192021222324252627282930313233@Configuration@EnableConfigurationProperties@EnableAutoConfiguration@MapperScan(basePackages = "com.tomalen.springlanuch.generator.db2", sqlSessionTemplateRef = "secondarySqlSessionTemplate")public class SecondaryDataSourceJTAConfig &#123; @Bean("secondaryDataSource") @ConfigurationProperties(prefix = "secondarydb") @Primary public DataSource secondaryDataSource() &#123; return new AtomikosDataSourceBean(); &#125; @Bean("secondarySqlSessionFactory") @Primary public SqlSessionFactory secondarySqlSessionFactory(@Qualifier("secondaryDataSource") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); //bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml")); bean.setTypeAliasesPackage("com.tomalen.springlanuch.generator.db2"); return bean.getObject(); &#125; @Bean("secondarySqlSessionTemplate") @Primary public SqlSessionTemplate secondarySqlSessionTemplate( @Qualifier("secondarySqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; db1 和 db2 的目录结构 修改ArticleServiceImpl文件，将message插入进去123456789101112131415@Autowiredprivate ArticleMapper articleMapper;@Autowiredprivate MessageDao messageDao;@Overridepublic int saveArticle(Article article) &#123; //测试分布式管理，同时插入两个数据库 Message message = new Message(); message.setName("Kobe"); message.setContent("Shoot Three points!"); messageDao.insert(message); return articleMapper.insert(article);&#125; 具体测试使用postMan调试接口，有兴趣可以学习下~ 这里不赘述。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>jta-atomikos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot整合Mybatis]]></title>
    <url>%2F2019%2F08%2F18%2FSpringBoot%E6%95%B4%E5%90%88Mybatis%2F</url>
    <content type="text"><![CDATA[SpringBoot整合Mybatis什么是Mybatis？MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。相对于Spring Data JPA来说，可以有非常直观的动态SQL，SQL可以写在XML里面，独立管理，动态SQL语法也容易书写与理解，易于对SQL的编写。 将Mybatis集成到Spring Boot1、引入maven依赖包123456789&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; 2、保证application.yml里面有数据库连接的配置12345678910111213141516171819#spring的相关配置spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT+8 datasource: url: jdbc:mysql://localhost:3306/springboot username: root password: root driver-class-name: com.mysql.jdbc.Driver#Mybatis的Mapper的xml文件的路径mybatis: mapper-locations: classpath:/mybatis/mapper/*.xml#相关的日志配置logging: level: com.zimug.bootlaunch: debug 3、配置Mybatis的Mapper的扫描路径123456789@SpringBootApplication@MapperScan(basePackages = &#123;"com.tomalen.springlanuch.Dao"&#125;)public class SpringLanuchApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringLanuchApplication.class, args); &#125;&#125; 安装mybatis generator插件1、安装插件 如果遇到上不了网，就登录IntellJ IDEA 的官网下载插件-->http://plugins.jetbrains.com 2、在Settings–&gt;Tool–&gt;Mybatis Generator Plugin配置相关的路径 3、在IDEA上配置mySql 以上就是SpringBoot集成MyBatis。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 整合 spring Data JPA]]></title>
    <url>%2F2019%2F08%2F16%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Spring Boot 整合 spring Data JPA什么是 spring Data JPA？Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，底层使用了 Hibernate 的 JPA 技术实现，底层应用了Hibernate的具体配置。可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！ Spring Data JPA 可以极大提高开发效率。 将Spring Data JPA集成到Spring Boot1、使用maven依赖的方式，JPA依赖包和mysql驱动。12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 2、修改application.yml12345678910111213spring: datasource: primary: jdbc-url: jdbc:mysql://localhost:3306/springboot username: root password: root driver-class-name: com.mysql.jdbc.Driver jpa: hibernate: ddl-auto: update database: mysql show-sql: true create：每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 reate-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。 validate：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 基础核心用法实体类 VO实体类 : 可与关联相对应的对象，用于展示的实体类。 123456789101112131415@Data@Builder@AllArgsConstructor@NoArgsConstructorpublic class ArticleVO &#123; private Integer id; private String name; private String title; private String content; private Date createTime; private ArrayList&lt;Reader&gt; readers;` PO实体类：数据库持久层，与数据库中的数据相关联，属于平面实体类，不关联其他的对象。 1234567891011121314151617181920212223@Data@AllArgsConstructor@NoArgsConstructor@Builder@Entity@Table(name="article")public class ArticlePO &#123; @Id @GeneratedValue private Long id; @Column(nullable = false,length = 32) private String name; @Column(nullable = false, unique = true,length = 32) private String title; @Column(length = 512) private String content; private Date createTime;` 数据库操作接口：XxxRepository继承 JpaRepository&lt;T,ID&gt;为我们提供了各种针对单表的数据操作方法，用就完了。123//继承jpa，类型为Article，主键的类型为Longpublic interface ArticleRepository extends JpaRepository&lt;Article,Long&gt; &#123;&#125; service层接口:12345678910111213public interface ArticleRestService &#123; ArticleVO saveArticle(ArticleVO article); void deleteArticle(Long id); void updateArticle(ArticleVO article); ArticleVO getArticle(Long id); List&lt;ArticleVO&gt; getAll();&#125; Service层实现类：123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class ArticleJPARestService implements ArticleRestService &#123; @Resource private ArticleRepository articleRepository; @Resource private Mapper dozerMapper; public ArticleVO saveArticle( ArticleVO article) &#123; //把Vo实体类转为PO实体类 Article articlePO = dozerMapper.map(article,Article.class); articleRepository.save(articlePO); return article; &#125; @Override public void deleteArticle(Long id) &#123; articleRepository.deleteById(id); &#125; @Override public void updateArticle(ArticleVO article) &#123; Article articlePO = dozerMapper.map(article,Article.class); articleRepository.save(articlePO); &#125; @Override public ArticleVO getArticle(Long id) &#123; Optional&lt;Article&gt; article = articleRepository.findById(id); return dozerMapper.map(article.get(),ArticleVO.class); &#125; @Override public List&lt;ArticleVO&gt; getAll() &#123; List&lt;Article&gt; articleLis = articleRepository.findAll(); return DozerUtils.mapList(articleLis,ArticleVO.class); &#125;&#125; 总结总体而言，Spring Data JPA的用法相对简单，其自身带有的方法非常的多，用起来非常的便捷。但是相对于Mybatis来说不利于动态的sql查询，显得非常笨重。但是相对于hibernate来说简化了配置，底层也继承了hibernate的原理。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>spring Data JPA</tag>
      </tags>
  </entry>
</search>
